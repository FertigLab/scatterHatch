pointGrob
pointGrob()
grid::circleGrob()
legendIcon <- function(color, lineColor="black", lineType = "solid", patternType){
# tried to render the legend icons by creating new magick object but issue with grDevices prevented usage of ggsave
# instead using grid to render legend icons
if (patternType == "horizontal"){
return(grid::grobTree(
grid::circleGrob(0.5, 0.5, 0.5, gp=grid::gpar(col=color, lwd=1)),
grid::linesGrob(x=c(0,1), y=c(0.5, 0.5)),
grid::linesGrob(x=c(-sqrt((0.5^2)-(0.25^2)) + 0.5, sqrt((0.5^2)-(0.25^2)) +0.5), y=c(0.25, 0.25)),
grid::linesGrob(x=c(-sqrt((0.5^2)-(0.25^2)) + 0.5, sqrt((0.5^2)-(0.25^2)) +0.5), y=c(0.75, 0.75)),
gp = grid::gpar(
col = lineColor,
fill = color,
lwd = 1.5,
lty = lineType
)
))
}
if (patternType == "vertical"){
return(grid::grobTree(
grid::circleGrob(0.5, 0.5, 0.5, gp=grid::gpar(col=color, lwd=1)),
grid::linesGrob(y=c(0,1), x=c(0.5, 0.5)),
grid::linesGrob(y=c(-sqrt((0.5^2)-(0.25^2)) + 0.5, sqrt((0.5^2)-(0.25^2)) +0.5), x=c(0.25, 0.25)),
grid::linesGrob(y=c(-sqrt((0.5^2)-(0.25^2)) + 0.5, sqrt((0.5^2)-(0.25^2)) +0.5), x=c(0.75, 0.75)),
gp = grid::gpar(
col = lineColor,
fill = color,
lwd = 1.5,
lty = lineType
)
))
}
if (patternType == "positiveDiagnol"){
return(grid::grobTree(
grid::circleGrob(0.5, 0.5, 0.5, gp=grid::gpar(col=color, lwd=1)),
grid::linesGrob(x=c(-sqrt((0.5)^2/2)+0.5,sqrt((0.5)^2/2)+0.5), y=c(-sqrt((0.5)^2/2)+0.5, sqrt((0.5)^2/2)+0.5)),
grid::linesGrob(x=c(0.01779486, 0.6322051), y=c(0.3677949, 0.9822051)),
grid::linesGrob(x=c(0.3677949, 0.9822051), y=c(0.01779486, 0.6322051)),
gp = grid::gpar(
col = lineColor,
fill = color,
lwd = 1.75,
lty = lineType
)
))
}
if (patternType == "negativeDiagnol"){
return(grid::grobTree(
grid::circleGrob(0.5, 0.5, 0.5, gp=grid::par(col=color, lwd=1)),
grid::linesGrob(x=c(-sqrt((0.5)^2/2)+0.5,sqrt((0.5)^2/2)+0.5), y=c(sqrt((0.5)^2/2)+0.5, -sqrt((0.5)^2/2)+0.5)),
grid::linesGrob(x=c(0.01779486, 0.6322051), y=c(0.6322051, 0.01779486)),
grid::linesGrob(x=c(0.3677949, 0.9822051), y=c(0.9822051, 0.3677949)),
gp = grid::gpar(
col = lineColor,
fill = color,
lwd = 1.75,
lty = lineType
)
))
}
}
devtools::document()
devtools::document()
devtools::document()
devtools::document()
geom_imagePoint <- function(mapping = NULL, data = NULL, stat = "identity",
position = "identity", na.rm = FALSE, show.legend = NA,
inherit.aes = TRUE, ...) {
ggplot2::layer(
geom = imagePoints, mapping = mapping,  data = data, stat = stat,
position = position, show.legend = show.legend, inherit.aes = inherit.aes,
params = list(na.rm = na.rm, ...)
)
}
countGridPoints <- function(x, y, xDiff, yDiff, n = 25){
xIntervals = as.numeric(cut(x, breaks = seq(xDiff[1], xDiff[2], by=diff(xDiff)/(n-1))))
yIntervals = as.numeric(cut(y, breaks = seq(yDiff[2], yDiff[1], by=-1*diff(yDiff)/(n-1))))
yIntervals = n+1-yIntervals
intervals = as.data.frame(cbind(xIntervals, yIntervals))
pointsToGrid = as.data.frame(cbind(xIntervals, yIntervals, x, y))
freqs = count(intervals, vars=c("xIntervals", "yIntervals"))
freqMat = matrix(0, nrow=n, ncol=n)
for (x in 1:nrow(freqs)){
freqMat[freqs$yIntervals[x], freqs$xIntervals[x]] = freqs$freq[x]
}
xLevels = seq(xDiff[1], xDiff[2], by=diff(xDiff)/(n-1))
yLevels = seq(yDiff[2], yDiff[1], by=-1*diff(yDiff)/(n-1))
return(list(xLevels, yLevels, freqMat, pointsToGrid))
}
.pt
.stroke
ggplot2::.pt
ggplot2::.pt + ggplot2::.stroke*0.5/2
devtools::document()
#draws the horizontal line pattern
source("patternHelpFunctions.R")
getwd()
#draws the horizontal line pattern
source("R/patternHelpFunctions.R")
#draws the horizontal line pattern
source("R/patternHelperFunctions.R")
devtools::document()
rm(list = c("convertSizeToCartesian", "countGridPoints"))
devtools::document()
devtools::document()
rm(list = c("convertSizeToCartesian", "countGridPoints"))
devtools::document()
devtools::document()
rm(list = c("convertSizeToCartesian", "countGridPoints"))
devtools::document()
#draws the horizontal line pattern
devtools::load_all()
devtools::load_all("patternHelperFunctions.R")
getwd()
devtools::load_all("R/patternHelperFunctions.R")
drawHorizontal <- function(gridOutput, density = 1/2, sparsity = 5, size = 1, xDiff, yDiff){
if (density > 1){density=1} #density must be 1 or less
xBins = gridOutput[[1]]
yBins = gridOutput[[2]]
freqMat = gridOutput[[3]]
pointsToGrid = gridOutput[[4]]
xStart = c()
yStart = c()
xEnd = c()
yEnd = c()
adjustmentFactorX = convertSizeToCartesian(size, xDiff, 'x')
adjustmentFactorY = convertSizeToCartesian(size, yDiff, 'y')
rowDraw = TRUE # wheater to draw lines in current row or not
for (row in 1:nrow(freqMat)){ # iterates by every row
currentRow = freqMat[row, ]
rowPoints = pointsToGrid[pointsToGrid$yIntervals == row, ]
if (density <= 1 & row+1 <= nrow(freqMat)){  # where to draw y levels if density < 1
yLevels = median(rowPoints$y)
}
if (density <= 1){ # if density < 1, when to skip rows
rowDraw = (as.integer(row * density)*(1/density)) == row
}
if (row + 1 > nrow(freqMat)){ # for top rows exception case
yLevels = yBins[row]
}
prevCol = 0
lineDraw = FALSE # wheather line being drawn or not
for (col in 1:ncol(freqMat)){
if (!lineDraw & prevCol == 0 & freqMat[row, col] != 0 & rowDraw){ # starting a line segment
gridPoints = rowPoints[rowPoints$xIntervals == col, ] # points corresponding to current grid square
xStart = c(xStart, min(gridPoints$x) - adjustmentFactorX) # where to draw horizontal lines
yStart = c(yStart, yLevels)
lineDraw = TRUE
}
if (lineDraw & currentRow[col] == 0 & rowDraw){ # ending line segment
gridPoints = rowPoints[rowPoints$xIntervals == col-1, ] # points corresponding to current grid square
xEnd = c(xEnd, max(gridPoints$x) + adjustmentFactorX) # where to draw horizontal lines
yEnd = c(yEnd, yLevels)
lineDraw = FALSE
}
# dealing with sparse points
surroundingGrid = c((col-sparsity):(col-1), (col+1):(col+sparsity))
surroundingGrid = surroundingGrid[surroundingGrid > 0 & surroundingGrid < ncol(freqMat)] # grids sparsity horizontal distance away
if (sum(currentRow[surroundingGrid]) <= 0 & currentRow[col] != 0 & !lineDraw){
gridPoints = rowPoints[rowPoints$xIntervals == col, ]
xStart = c(xStart, min(gridPoints$x) - adjustmentFactorX) # where to draw horizontal lines
yStart = c(yStart, median(gridPoints$y))
xEnd = c(xEnd, max(gridPoints$x) + adjustmentFactorX) # where to draw horizontal lines
yEnd = c(yEnd, median(gridPoints$y))
}
prevCol = currentRow[col]
}
}
return(data.frame(xStart=xStart, yStart=yStart, xEnd=xEnd, yEnd=yEnd))
}
devtools::document()
rm(list = c("drawHorizontal"))
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
